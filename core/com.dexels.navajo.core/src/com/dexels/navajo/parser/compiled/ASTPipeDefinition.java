/* Generated By:JJTree: Do not edit this line. ASTPipeDefinition.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=true,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.dexels.navajo.parser.compiled;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.function.Function;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.dexels.navajo.document.stream.DataItem;
import com.dexels.navajo.document.stream.api.StreamScriptContext;
import com.dexels.navajo.expression.api.ContextExpression;
import com.dexels.navajo.expression.api.FunctionClassification;
import com.dexels.navajo.parser.compiled.api.ReactivePipeNode;
import com.dexels.navajo.reactive.api.ReactiveSource;
import com.dexels.navajo.reactive.api.ReactiveTransformer;

public
class ASTPipeDefinition extends SimpleNode {
  public int args = 0;
  public boolean partial = false;
  
  
  private static final Logger logger = LoggerFactory.getLogger(ASTPipeDefinition.class);


  public ASTPipeDefinition(int id) {
    super(id);
  }
  
  @SuppressWarnings("unchecked")
private List<Object> transformerElements(List<String> problems, String originalExpression, Function<String, FunctionClassification> functionClassifier, Function<String,Optional<Node>> mapResolver) {
	  	int count = jjtGetNumChildren();
	  	List<Object> pipeElements = new ArrayList<>();
	  	for (int i = (partial?0:1); i < count; i++) {
	  		ContextExpression interpretToLambda = jjtGetChild(i).interpretToLambda(problems, originalExpression,functionClassifier,mapResolver);
	  		Object result = interpretToLambda.apply().value;
	  		if(result instanceof Function) {
	  			Function<StreamScriptContext,Function<DataItem,DataItem>> merger = (Function<StreamScriptContext,Function<DataItem,DataItem>>) result;
	  			pipeElements.add(merger);

	  		} else if(result instanceof ReactiveTransformer) {
	  			ReactiveTransformer transformer = (ReactiveTransformer) result;
	  			pipeElements.add(transformer);
	  		} else {
	  			logger.warn("huh? {}",result);
	  			// something weird
	  		}
	  	}	 
	  	return pipeElements;
  }
  
  @Override
  public ContextExpression interpretToLambda(List<String> problems, String originalExpression, Function<String, FunctionClassification> functionClassifier, Function<String,Optional<Node>> mapResolver) {
	 if(partial) {
		  	return new ReactivePipeNode(Optional.empty(), transformerElements(problems, originalExpression, functionClassifier, mapResolver));
	 } else {
		  	ReactiveSource sourceNode = (ReactiveSource) jjtGetChild(0).interpretToLambda(problems, "",fn->FunctionClassification.REACTIVE_SOURCE,mapResolver).apply().value;
		  	return new ReactivePipeNode(Optional.of(sourceNode), transformerElements(problems, originalExpression, functionClassifier, mapResolver));
	 }
  	

  }
}
/* JavaCC - OriginalChecksum=e2f99ca4133af324ac89708758019188 (do not edit this line) */
