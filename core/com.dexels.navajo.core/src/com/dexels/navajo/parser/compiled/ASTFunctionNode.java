/* Generated By:JJTree&JavaCC: Do not edit this line. ASTFunctionNode.java */
package com.dexels.navajo.parser.compiled;

import java.util.LinkedList;
import java.util.List;
import java.util.Optional;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.dexels.config.runtime.RuntimeConfig;
import com.dexels.immutable.api.ImmutableMessage;
import com.dexels.navajo.document.Message;
import com.dexels.navajo.document.Navajo;
import com.dexels.navajo.document.Selection;
import com.dexels.navajo.functions.util.FunctionFactoryFactory;
import com.dexels.navajo.functions.util.OSGiFunctionFactoryFactory;
import com.dexels.navajo.parser.FunctionInterface;
import com.dexels.navajo.parser.TMLExpressionException;
import com.dexels.navajo.parser.compiled.api.ContextExpression;
import com.dexels.navajo.script.api.Access;
import com.dexels.navajo.script.api.MappableTreeNode;
import com.dexels.navajo.server.DispatcherFactory;
import com.dexels.navajo.tipilink.TipiLink;
import com.dexels.navajo.version.AbstractVersion;


public final class ASTFunctionNode extends SimpleNode {

	
	private final static Logger typechecklogger = LoggerFactory.getLogger("navajo.typecheck");

	String functionName;
	int args = 0;
	
	public ASTFunctionNode(int id) {
		super(id);
	}
	
	private FunctionInterface getFunction() {
		ClassLoader cl = null;
		if ( DispatcherFactory.getInstance() == null ) {
			cl = getClass().getClassLoader();
		} else  {
			cl = DispatcherFactory.getInstance().getNavajoConfig().getClassloader();
		} 

		FunctionInterface f = AbstractVersion.osgiActive() ? OSGiFunctionFactoryFactory.getFunctionInterface(functionName) :
			FunctionFactoryFactory.getInstance().getInstance(cl, functionName);
		return f;
	}
	
	@Override
	public ContextExpression interpretToLambda(List<String> problems,String expression) {


		List<ContextExpression> l = new LinkedList<>();
		
		// BEWARE: Don't actually use this function object, as it might have threading conflicts
		FunctionInterface typeCheckInstance = getFunction();
		if(typeCheckInstance==null) {
			throw new NullPointerException("Function: "+functionName+" can not be resolved!");
		}

		// TODO Type check input parameters
		for (int i = 0; i < args; i++) {
			ContextExpression a = jjtGetChild(i).interpretToLambda(problems,expression);
			l.add(a);
		}
		try {
			List<String> typeProblems = typeCheckInstance.typeCheck(l,expression);
			if(!typeProblems.isEmpty()) {
				if(RuntimeConfig.STRICT_TYPECHECK.getValue()!=null) {
					problems.addAll(typeProblems);
				}
			}
		} catch (Throwable e2) {
			typechecklogger.error("Typechecker itself failed. Error: ", e2);
		}
		
		return new ContextExpression() {
			
			@Override
			public boolean isLiteral() {
				return typeCheckInstance.isPure() && l.stream().allMatch(e->e.isLiteral());
			}
			
//			List<String> problems
			@Override
			public Object apply(Navajo doc, Message parentMsg, Message parentParamMsg, Selection parentSel,
					 MappableTreeNode mapNode, TipiLink tipiLink, Access access, Optional<ImmutableMessage> immutableMessage, Optional<ImmutableMessage> paramMessage) throws TMLExpressionException {
				FunctionInterface f = getFunction();
				f.setInMessage(doc);
				f.setCurrentMessage(parentMsg);
				f.setAccess(access);
				f.reset();
				l.stream()
					.map(e->{
						try {
							return e.apply(doc, parentMsg, parentParamMsg, parentSel, mapNode,tipiLink, access,immutableMessage,paramMessage);
						} catch (TMLExpressionException e1) {
							throw new RuntimeException("Error parsing parameters for function: "+functionName, e1);
						}
					})
					.forEach(e->f.insertOperand(e));
				return f.evaluateWithTypeChecking();
			}

			@Override
			public Optional<String> returnType() {
				return typeCheckInstance.getReturnType();
			}
			@Override
			public String expression() {
				return expression;
			}
		};
	}

}
