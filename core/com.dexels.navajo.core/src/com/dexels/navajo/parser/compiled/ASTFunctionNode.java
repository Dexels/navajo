/*
This file is part of the Navajo Project. 
It is subject to the license terms in the COPYING file found in the top-level directory of this distribution and at https://www.gnu.org/licenses/agpl-3.0.txt. 
No part of the Navajo Project, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYING file.
*/
/* Generated By:JJTree&JavaCC: Do not edit this line. ASTFunctionNode.java */
package com.dexels.navajo.parser.compiled;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.dexels.immutable.api.ImmutableMessage;
import com.dexels.navajo.document.Message;
import com.dexels.navajo.document.Navajo;
import com.dexels.navajo.document.Operand;
import com.dexels.navajo.document.Selection;
import com.dexels.navajo.expression.api.ContextExpression;
import com.dexels.navajo.expression.api.FunctionClassification;
import com.dexels.navajo.expression.api.FunctionInterface;
import com.dexels.navajo.expression.api.TMLExpressionException;
import com.dexels.navajo.expression.api.TipiLink;
import com.dexels.navajo.functions.util.FunctionFactoryFactory;
import com.dexels.navajo.functions.util.OSGiFunctionFactoryFactory;
import com.dexels.navajo.parser.NamedExpression;
import com.dexels.navajo.parser.compiled.api.CacheSubexpression;
import com.dexels.navajo.parser.compiled.api.ReactiveParseItem;
import com.dexels.navajo.reactive.api.Reactive;
import com.dexels.navajo.runtime.config.RuntimeConfig;
import com.dexels.navajo.script.api.Access;
import com.dexels.navajo.script.api.MappableTreeNode;
import com.dexels.navajo.server.DispatcherFactory;
import com.dexels.navajo.version.AbstractVersion;


final class ASTFunctionNode extends SimpleNode {

	
	private static final Logger typechecklogger = LoggerFactory.getLogger("navajo.typecheck");

	
	private static final Logger logger = LoggerFactory.getLogger(ASTFunctionNode.class);

	String functionName;
	int args = 0;
	
	ASTFunctionNode(int id) {
		super(id);
	}
	
	private FunctionInterface getFunction() {
		ClassLoader cl = null;
		if ( DispatcherFactory.getInstance() == null ) {
			cl = getClass().getClassLoader();
		} else  {
			cl = DispatcherFactory.getInstance().getNavajoConfig().getClassloader();
		} 

		return AbstractVersion.osgiActive() ? OSGiFunctionFactoryFactory.getFunctionInterface(functionName) :
			FunctionFactoryFactory.getInstance().getInstance(cl, functionName);
	}
	
	@Override
	public ContextExpression interpretToLambda(List<String> problems,String expression, Function<String, FunctionClassification> functionClassifier, Function<String,Optional<Node>> mapResolver) {


		List<ContextExpression> unnamed = new LinkedList<>();
		// TODO make lazy?
		Map<String,ContextExpression> named = new HashMap<>();

		for (int i = 0; i <jjtGetNumChildren(); i++) {
			Node sn = jjtGetChild(i);
			ContextExpression cn = sn.interpretToLambda(problems, expression,functionClassifier,mapResolver);
			if(cn instanceof NamedExpression) {
				NamedExpression ne = (NamedExpression)cn;
				named.put(ne.name, ne.expression);
			} else {
				unnamed.add(cn);
			}
		}
		
		FunctionClassification mode = functionClassifier.apply(functionName);
		switch (mode) {
			
			case REACTIVE_HEADER:
				
				break;
			case REACTIVE_SOURCE:
				return new ReactiveParseItem(functionName, Reactive.ReactiveItemType.REACTIVE_SOURCE, named, unnamed, expression,this);
			case REACTIVE_TRANSFORMER:
				return new ReactiveParseItem(functionName, Reactive.ReactiveItemType.REACTIVE_TRANSFORMER, named, unnamed, expression,this);
	
			case REACTIVE_REDUCER:
				return new ReactiveParseItem(functionName, Reactive.ReactiveItemType.REACTIVE_MAPPER, named, unnamed, expression,this);
			case DEFAULT:
				default:
		}
		return resolveNormalFunction(unnamed, named, problems, expression);

	}
	
	private ContextExpression resolveNormalFunction(List<ContextExpression> l, Map<String, ContextExpression> named,
			List<String> problems, String expression) {
		FunctionInterface typeCheckInstance = getFunction();
		if(typeCheckInstance==null) {
			throw new NullPointerException("Function: "+functionName+" can not be resolved!");
		}

		try {
			List<String> typeProblems = typeCheckInstance.typeCheck(l,expression);
			if(!typeProblems.isEmpty() && RuntimeConfig.STRICT_TYPECHECK.getValue()!=null) {
				problems.addAll(typeProblems);
			}
		} catch (Throwable e2) {
			typechecklogger.error("Typechecker itself failed when parsing: "+expression+" function definition: "+typeCheckInstance+" Error: ", e2);
		}
		boolean isImmutable = typeCheckInstance.isPure() && l.stream().allMatch(e->e.isLiteral());

		ContextExpression dynamic = new ContextExpression() {
			
			@Override
			public boolean isLiteral() {
				// TODO also check named params
				return isImmutable;
			}
			
			@Override
			public Operand apply(Navajo doc, Message parentMsg, Message parentParamMsg, Selection parentSel,
					 MappableTreeNode mapNode, TipiLink tipiLink, Access access, Optional<ImmutableMessage> immutableMessage, Optional<ImmutableMessage> paramMessage) {
				FunctionInterface f = getFunction();
				Map<String,Operand> resolvedNamed = named.entrySet().stream().collect(Collectors.toMap(e->e.getKey(),e->e.getValue().apply(doc, parentMsg, parentParamMsg, parentSel, mapNode,tipiLink, access,immutableMessage,paramMessage)));
				f.setInMessage(doc);
				f.setNamedParameter(resolvedNamed);
				f.setCurrentMessage(parentMsg);
				f.setAccess(access);
				f.reset();
				l.stream()
					.map(e->{
						try {
							Operand evaluated = e.apply(doc, parentMsg, parentParamMsg, parentSel, mapNode,tipiLink, access,immutableMessage,paramMessage);
							if(evaluated==null) {
								logger.warn("Problematic expression returned null object. If you really insist, return an Operand.NULL. Evaluating expression: {}",expression);
								
							}
							return evaluated;
						} catch (TMLExpressionException e1) {
							throw new TMLExpressionException("Error parsing parameters for function: "+functionName, e1);
						}
					})
					.forEach(e->f.insertOperand(e));
				return f.evaluateWithTypeCheckingOperand();
			}

			@Override
			public Optional<String> returnType() {
				return typeCheckInstance.getReturnType();
			}
			@Override
			public String expression() {
				return expression;
			}
		};
		if(isImmutable && CacheSubexpression.getCacheSubExpression()) {
			Optional<String> returnType = dynamic.returnType();
			String immutablExpression = dynamic.expression();
			Operand resolved = dynamic.apply();
			return new ContextExpression() {
				
				@Override
				public Optional<String> returnType() {
					return returnType;
				}
				
				@Override
				public boolean isLiteral() {
					return true;
				}
				
				@Override
				public String expression() {
					return immutablExpression;
				}
				
				@Override
				public Operand apply(Navajo doc, Message parentMsg, Message parentParamMsg, Selection parentSel,
						MappableTreeNode mapNode, TipiLink tipiLink, Access access, Optional<ImmutableMessage> immutableMessage,
						Optional<ImmutableMessage> paramMessage) {
					return resolved;
				}
			};
		} else {
			return dynamic;
		}

	}

}
