/* Generated By:JJTree: Do not edit this line. ASTReactiveScriptNode.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.dexels.navajo.parser.compiled;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Function;

import com.dexels.immutable.api.ImmutableMessage;
import com.dexels.navajo.document.Message;
import com.dexels.navajo.document.Navajo;
import com.dexels.navajo.document.Operand;
import com.dexels.navajo.document.Selection;
import com.dexels.navajo.expression.api.ContextExpression;
import com.dexels.navajo.expression.api.FunctionClassification;
import com.dexels.navajo.expression.api.TMLExpressionException;
import com.dexels.navajo.expression.api.TipiLink;
import com.dexels.navajo.parser.NamedExpression;
import com.dexels.navajo.parser.compiled.api.ReactivePipeNode;
import com.dexels.navajo.reactive.api.Reactive;
import com.dexels.navajo.script.api.Access;
import com.dexels.navajo.script.api.MappableTreeNode;

public
class ASTReactiveScriptNode extends SimpleNode {
  public int args = 0;
  public int headers = 0;
  public boolean hasHeader = false;
  public ASTFunctionNode header = null;
  private final Map<String,Operand> headerMap = new HashMap<>();
  public ASTReactiveScriptNode(int id) {
    super(id);
  }

@Override
public ContextExpression interpretToLambda(List<String> problems, String originalExpression, Function<String, FunctionClassification> functionClassifier) {
	// TODO support headers;
	List<ReactivePipeNode> pipes = new ArrayList<>();
	int start = hasHeader ? headers : 0;
	
	if(hasHeader) {
		for (int i = 0; i < headers; i++) {
			ASTKeyValueNode hdr = (ASTKeyValueNode) jjtGetChild(i);	
			NamedExpression ne = (NamedExpression) hdr.interpretToLambda(problems, originalExpression, functionClassifier);
			String key = ne.name;
			headerMap.put(key, ne.apply());
		}
	}
	int count = jjtGetNumChildren();
	for (int i = start; i < count; i++) {
		Node child = jjtGetChild(i);
		ASTReactivePipe pipe = null;
		if(child instanceof ASTReactivePipe) {
			pipe = (ASTReactivePipe) child;
		} else {
			pipe = new ASTReactivePipe(1);
			pipe.jjtAddChild(child, 0);
		}
		ReactivePipeNode node = (ReactivePipeNode) pipe.interpretToLambda(problems,originalExpression,functionClassifier);
		pipes.add(node);
	}
	return new ContextExpression() {
		
		@Override
		public Optional<String> returnType() {
			return Optional.of(Reactive.ReactiveItemType.REACTIVE_SCRIPT.toString());
		}
		
		@Override
		public boolean isLiteral() {
			return true;
		}
		
		@Override
		public String expression() {
			return "";
		}
		
		@Override
		public Operand apply(Navajo doc, Message parentMsg, Message parentParamMsg, Selection parentSel,
				MappableTreeNode mapNode, TipiLink tipiLink, Access access, Optional<ImmutableMessage> immutableMessage,
				Optional<ImmutableMessage> paramMessage) throws TMLExpressionException {
			return Operand.ofCustom(pipes, Reactive.ReactiveItemType.REACTIVE_SCRIPT.toString());
		}
	};
}

	public List<String> methods() {
		String methodStr = this.headerMap.getOrDefault("methods", Operand.ofString("")).stringValue();
		return Arrays.asList(methodStr.split(","));
		
	}
}
/* JavaCC - OriginalChecksum=1b3774ce274fd31113ba44556c6878a0 (do not edit this line) */
