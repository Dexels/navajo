/* Generated By:JJTree: Do not edit this line. ASTReactivePipe.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.dexels.navajo.parser.compiled;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.function.Function;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.dexels.immutable.api.ImmutableMessage;
import com.dexels.navajo.document.Message;
import com.dexels.navajo.document.Navajo;
import com.dexels.navajo.document.Operand;
import com.dexels.navajo.document.Selection;
import com.dexels.navajo.document.stream.DataItem;
import com.dexels.navajo.document.stream.api.StreamScriptContext;
import com.dexels.navajo.expression.api.ContextExpression;
import com.dexels.navajo.expression.api.FunctionClassification;
import com.dexels.navajo.expression.api.TipiLink;
import com.dexels.navajo.parser.compiled.api.ReactivePipeNode;
import com.dexels.navajo.reactive.api.ReactiveSource;
import com.dexels.navajo.reactive.api.ReactiveTransformer;
import com.dexels.navajo.script.api.Access;
import com.dexels.navajo.script.api.MappableTreeNode;


class ASTReactivePipeSegment extends SimpleNode {
	
	
	private static final Logger logger = LoggerFactory.getLogger(ASTReactivePipeSegment.class);

public int args = 0;
  ASTReactivePipeSegment(int id) {
    super(id);
  }

@SuppressWarnings("unchecked")
@Override
public ContextExpression interpretToLambda(List<String> problems, String originalExpression, Function<String, FunctionClassification> functionClassifier, Function<String,Optional<Node>> mapResolver) {
	ASTPipeline actual = (ASTPipeline) jjtGetChild(0);

	int count = actual.jjtGetNumChildren();
//	ReactiveSource sourceNode = (ReactiveSource) actual.jjtGetChild(0).interpretToLambda(problems, "",fn->FunctionClassification.REACTIVE_SOURCE,mapResolver).apply().value;
	List<Object> pipeElements = new ArrayList<>();

	for (int i = 0; i < count; i++) {
		ContextExpression interpretToLambda = actual.jjtGetChild(i).interpretToLambda(problems, originalExpression,functionClassifier,mapResolver);
		Object result = interpretToLambda.apply().value;
		if(result instanceof Function) {
			Function<StreamScriptContext,Function<DataItem,DataItem>> merger = (Function<StreamScriptContext,Function<DataItem,DataItem>>) result;
			pipeElements.add(merger);

		} else if(result instanceof ReactiveTransformer) {
			ReactiveTransformer transformer = (ReactiveTransformer) result;
			pipeElements.add(transformer);
		} else {
			logger.warn("huh? {}",result);
			// something weird
		}
	}
	return new ContextExpression() {
		
		@Override
		public Optional<String> returnType() {
			// TODO Auto-generated method stub
			return null;
		}
		
		@Override
		public boolean isLiteral() {
			// unsure
			return false;
		}
		
		@Override
		public String expression() {
			return originalExpression;
		}
		
		@Override
		public Operand apply(Navajo doc, Message parentMsg, Message parentParamMsg, Selection parentSel,
				MappableTreeNode mapNode, TipiLink tipiLink, Access access, Optional<ImmutableMessage> immutableMessage,
				Optional<ImmutableMessage> paramMessage) {
			return Operand.ofCustom(pipeElements,"PARTIALPIPE");
		}
	};
}

public void addSource() {
	args++;
}

public void addTransformer() {
	args++;
}

@Override
public void jjtClose() {
	super.jjtClose();

}



}
/* JavaCC - OriginalChecksum=dd1db8c7a34ea094a180c8dc73739db3 (do not edit this line) */
